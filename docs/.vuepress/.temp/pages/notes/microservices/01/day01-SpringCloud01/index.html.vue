<template><div><h1 id="springcloud01-🌸" tabindex="-1"><a class="header-anchor" href="#springcloud01-🌸" aria-hidden="true">#</a> SpringCloud01 🌸</h1>
<nav class="table-of-contents"><ul><li><router-link to="#_1-0-学习目标">1.0.学习目标</router-link></li><li><router-link to="#_1-1-单体架构">1.1.单体架构</router-link></li><li><router-link to="#_1-2-分布式架构">1.2.分布式架构</router-link></li><li><router-link to="#_1-3-微服务">1.3.微服务</router-link></li><li><router-link to="#_1-4-springcloud">1.4.SpringCloud</router-link></li><li><router-link to="#_1-5-总结">1.5.总结</router-link></li><li><router-link to="#_2-1-服务拆分原则">2.1.服务拆分原则</router-link></li><li><router-link to="#_2-2-服务拆分示例">2.2.服务拆分示例</router-link><ul><li><router-link to="#_2-2-1-导入-sql-语句">2.2.1.导入 Sql 语句</router-link></li><li><router-link to="#_2-2-2-导入-demo-工程">2.2.2.导入 demo 工程</router-link></li></ul></li><li><router-link to="#_2-3-实现远程调用案例">2.3.实现远程调用案例</router-link><ul><li><router-link to="#_2-3-1-案例需求">2.3.1.案例需求：</router-link></li><li><router-link to="#_2-3-2-注册-resttemplate">2.3.2.注册 RestTemplate</router-link></li><li><router-link to="#_2-3-3-实现远程调用">2.3.3.实现远程调用</router-link></li></ul></li><li><router-link to="#_2-4-提供者与消费者">2.4.提供者与消费者</router-link></li><li><router-link to="#_3-1-eureka-的结构和作用">3.1.Eureka 的结构和作用</router-link></li><li><router-link to="#_3-2-搭建-eureka-server">3.2.搭建 eureka-server</router-link><ul><li><router-link to="#_3-2-1-创建-eureka-server-服务">3.2.1.创建 eureka-server 服务</router-link></li><li><router-link to="#_3-2-2-引入-eureka-依赖">3.2.2.引入 eureka 依赖</router-link></li><li><router-link to="#_3-2-3-编写启动类">3.2.3.编写启动类</router-link></li><li><router-link to="#_3-2-4-编写配置文件">3.2.4.编写配置文件</router-link></li><li><router-link to="#_3-2-5-启动服务">3.2.5.启动服务</router-link></li></ul></li><li><router-link to="#_3-3-服务注册">3.3.服务注册</router-link><ul><li><router-link to="#_1-引入依赖">1）引入依赖</router-link></li><li><router-link to="#_2-配置文件">2）配置文件</router-link></li><li><router-link to="#_3-启动多个-user-service-实例">3）启动多个 user-service 实例</router-link></li></ul></li><li><router-link to="#_3-4-服务发现">3.4.服务发现</router-link><ul><li><router-link to="#_1-引入依赖-1">1）引入依赖</router-link></li><li><router-link to="#_2-配置文件-1">2）配置文件</router-link></li><li><router-link to="#_3-服务拉取和负载均衡">3）服务拉取和负载均衡</router-link></li></ul></li><li><router-link to="#_4-1-负载均衡原理">4.1.负载均衡原理</router-link></li><li><router-link to="#_4-2-源码跟踪">4.2.源码跟踪</router-link><ul><li><router-link to="#_1-loadbalancerintercepor">1）LoadBalancerIntercepor</router-link></li><li><router-link to="#_2-loadbalancerclient">2）LoadBalancerClient</router-link></li><li><router-link to="#_3-负载均衡策略-irule">3）负载均衡策略 IRule</router-link></li><li><router-link to="#_4-总结">4）总结</router-link></li></ul></li><li><router-link to="#_4-3-负载均衡策略">4.3.负载均衡策略</router-link><ul><li><router-link to="#_4-3-1-负载均衡策略">4.3.1.负载均衡策略</router-link></li><li><router-link to="#_4-3-2-自定义负载均衡策略">4.3.2.自定义负载均衡策略</router-link></li></ul></li><li><router-link to="#_4-4-饥饿加载">4.4.饥饿加载</router-link></li><li><router-link to="#_5-1-认识和安装-nacos">5.1.认识和安装 Nacos</router-link></li><li><router-link to="#_5-2-服务注册到-nacos">5.2.服务注册到 nacos</router-link><ul><li><router-link to="#_1-引入依赖-2">1）引入依赖</router-link></li><li><router-link to="#_2-配置-nacos-地址">2）配置 nacos 地址</router-link></li><li><router-link to="#_3-重启">3）重启</router-link></li></ul></li><li><router-link to="#_5-3-服务分级存储模型">5.3.服务分级存储模型</router-link><ul><li><router-link to="#_5-3-1-给-user-service-配置集群">5.3.1.给 user-service 配置集群</router-link></li><li><router-link to="#_5-3-2-同集群优先的负载均衡">5.3.2.同集群优先的负载均衡</router-link></li></ul></li><li><router-link to="#_5-4-权重配置">5.4.权重配置</router-link></li><li><router-link to="#_5-5-环境隔离">5.5.环境隔离</router-link><ul><li><router-link to="#_5-5-1-创建-namespace">5.5.1.创建 namespace</router-link></li><li><router-link to="#_5-5-2-给微服务配置-namespace">5.5.2.给微服务配置 namespace</router-link></li></ul></li><li><router-link to="#_5-6-nacos-与-eureka-的区别">5.6.Nacos 与 Eureka 的区别</router-link></li></ul></nav>
<h1 id="_1-认识微服务" tabindex="-1"><a class="header-anchor" href="#_1-认识微服务" aria-hidden="true">#</a> 1.认识微服务</h1>
<p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p>
<h2 id="_1-0-学习目标" tabindex="-1"><a class="header-anchor" href="#_1-0-学习目标" aria-hidden="true">#</a> 1.0.学习目标</h2>
<p>了解微服务架构的优缺点</p>
<h2 id="_1-1-单体架构" tabindex="-1"><a class="header-anchor" href="#_1-1-单体架构" aria-hidden="true">#</a> 1.1.单体架构</h2>
<p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713202807818.png" alt="image-20210713202807818"></p>
<p>单体架构的优缺点如下：</p>
<p><strong>优点：</strong></p>
<ul>
<li>架构简单</li>
<li>部署成本低</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>耦合度高（维护困难、升级困难）</li>
</ul>
<h2 id="_1-2-分布式架构" tabindex="-1"><a class="header-anchor" href="#_1-2-分布式架构" aria-hidden="true">#</a> 1.2.分布式架构</h2>
<p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713203124797.png" alt="image-20210713203124797"></p>
<p>分布式架构的优缺点：</p>
<p><strong>优点：</strong></p>
<ul>
<li>降低服务耦合</li>
<li>有利于服务升级和拓展</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>服务调用关系错综复杂</li>
</ul>
<p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p>
<ul>
<li>服务拆分的粒度如何界定？</li>
<li>服务之间如何调用？</li>
<li>服务的调用关系如何管理？</li>
</ul>
<p>人们需要制定一套行之有效的标准来约束分布式架构。</p>
<h2 id="_1-3-微服务" tabindex="-1"><a class="header-anchor" href="#_1-3-微服务" aria-hidden="true">#</a> 1.3.微服务</h2>
<p>微服务的架构特征：</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>自治：团队独立、技术独立、数据独立，独立部署和交付</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关</li>
<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>
</ul>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713203753373.png" alt="image-20210713203753373"></p>
<p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p>
<p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p>
<p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p>
<p>其中在 Java 领域最引人注目的就是 SpringCloud 提供的方案了。</p>
<h2 id="_1-4-springcloud" tabindex="-1"><a class="header-anchor" href="#_1-4-springcloud" aria-hidden="true">#</a> 1.4.SpringCloud</h2>
<p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。</p>
<p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p>
<p>其中常见的组件包括：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713204155887.png" alt="image-20210713204155887"></p>
<p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713205003790.png" alt="image-20210713205003790"></p>
<p>我们课堂学习的版本是 Hoxton.SR10，因此对应的 SpringBoot 版本是 2.3.x 版本。</p>
<h2 id="_1-5-总结" tabindex="-1"><a class="header-anchor" href="#_1-5-总结" aria-hidden="true">#</a> 1.5.总结</h2>
<ul>
<li>
<p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p>
</li>
<li>
<p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p>
</li>
<li>
<p>微服务：一种良好的分布式架构方案</p>
<p>① 优点：拆分粒度更小、服务更独立、耦合度更低</p>
<p>② 缺点：架构非常复杂，运维、监控、部署难度提高</p>
</li>
<li>
<p>SpringCloud 是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p>
</li>
</ul>
<h1 id="_2-服务拆分和远程调用" tabindex="-1"><a class="header-anchor" href="#_2-服务拆分和远程调用" aria-hidden="true">#</a> 2.服务拆分和远程调用</h1>
<p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p>
<h2 id="_2-1-服务拆分原则" tabindex="-1"><a class="header-anchor" href="#_2-1-服务拆分原则" aria-hidden="true">#</a> 2.1.服务拆分原则</h2>
<p>这里我总结了微服务拆分时的几个原则：</p>
<ul>
<li>不同微服务，不要重复开发相同业务</li>
<li>微服务数据独立，不要访问其它微服务的数据库</li>
<li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li>
</ul>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713210800950.png" alt="image-20210713210800950"></p>
<h2 id="_2-2-服务拆分示例" tabindex="-1"><a class="header-anchor" href="#_2-2-服务拆分示例" aria-hidden="true">#</a> 2.2.服务拆分示例</h2>
<p>以课前资料中的微服务 cloud-demo 为例，其结构如下：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713211009593.png" alt="image-20210713211009593"></p>
<p>cloud-demo：父工程，管理依赖</p>
<ul>
<li>order-service：订单微服务，负责订单相关业务</li>
<li>user-service：用户微服务，负责用户相关业务</li>
</ul>
<p>要求：</p>
<ul>
<li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li>
<li>订单服务和用户服务都对外暴露 Restful 的接口</li>
<li>订单服务如果需要查询用户信息，只能调用用户服务的 Restful 接口，不能查询用户数据库</li>
</ul>
<h3 id="_2-2-1-导入-sql-语句" tabindex="-1"><a class="header-anchor" href="#_2-2-1-导入-sql-语句" aria-hidden="true">#</a> 2.2.1.导入 Sql 语句</h3>
<p>首先，将课前资料提供的<code v-pre>cloud-order.sql</code>和<code v-pre>cloud-user.sql</code>导入到 mysql 中：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713211417049.png" alt="image-20210713211417049"></p>
<p>cloud-user 表中初始数据如下：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713211550169.png" alt="image-20210713211550169"></p>
<p>cloud-order 表中初始数据如下：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713211657319.png" alt="image-20210713211657319"></p>
<p>cloud-order 表中持有 cloud-user 表中的 id 字段。</p>
<h3 id="_2-2-2-导入-demo-工程" tabindex="-1"><a class="header-anchor" href="#_2-2-2-导入-demo-工程" aria-hidden="true">#</a> 2.2.2.导入 demo 工程</h3>
<p>用 IDEA 导入课前资料提供的 Demo：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713211814094.png" alt="image-20210713211814094"></p>
<p>项目结构如下：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713212656887.png" alt="image-20210713212656887"></p>
<p>导入后，会在 IDEA 右下角出现弹窗：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713212349272.png" alt="image-20210713212349272"></p>
<p>点击弹窗，然后按下图选择：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713212336185.png" alt="image-20210713212336185"></p>
<p>会出现这样的菜单：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713212513324.png" alt="image-20210713212513324"></p>
<p>配置下项目使用的 JDK：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713220736408.png" alt="image-20210713220736408"></p>
<h2 id="_2-3-实现远程调用案例" tabindex="-1"><a class="header-anchor" href="#_2-3-实现远程调用案例" aria-hidden="true">#</a> 2.3.实现远程调用案例</h2>
<p>在 order-service 服务中，有一个根据 id 查询订单的接口：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713212749575.png" alt="image-20210713212749575"></p>
<p>根据 id 查询订单，返回值是 Order 对象，如图：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713212901725.png" alt="image-20210713212901725"></p>
<p>其中的 user 为 null</p>
<p>在 user-service 中有一个根据 id 查询用户的接口：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713213146089.png" alt="image-20210713213146089"></p>
<p>查询的结果如图：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713213213075.png" alt="image-20210713213213075"></p>
<h3 id="_2-3-1-案例需求" tabindex="-1"><a class="header-anchor" href="#_2-3-1-案例需求" aria-hidden="true">#</a> 2.3.1.案例需求：</h3>
<p>修改 order-service 中的根据 id 查询订单业务，要求在查询订单的同时，根据订单中包含的 userId 查询出用户信息，一起返回。</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713213312278.png" alt="image-20210713213312278"></p>
<p>因此，我们需要在 order-service 中 向 user-service 发起一个 http 的请求，调用 http://localhost:8081/user/{userId}这个接口。</p>
<p>大概的步骤是这样的：</p>
<ul>
<li>注册一个 RestTemplate 的实例到 Spring 容器</li>
<li>修改 order-service 服务中的 OrderService 类中的 queryOrderById 方法，根据 Order 对象中的 userId 查询 User</li>
<li>将查询的 User 填充到 Order 对象，一起返回</li>
</ul>
<h3 id="_2-3-2-注册-resttemplate" tabindex="-1"><a class="header-anchor" href="#_2-3-2-注册-resttemplate" aria-hidden="true">#</a> 2.3.2.注册 RestTemplate</h3>
<p>首先，我们在 order-service 服务中的 OrderApplication 启动类中，注册 RestTemplate 实例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre v-pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>order</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>mybatis<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">MapperScan</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>client<span class="token punctuation">.</span></span><span class="token class-name">RestTemplate</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"cn.itcast.order.mapper"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderApplication</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">OrderApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-3-实现远程调用" tabindex="-1"><a class="header-anchor" href="#_2-3-3-实现远程调用" aria-hidden="true">#</a> 2.3.3.实现远程调用</h3>
<p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713213959569.png" alt="image-20210713213959569"></p>
<h2 id="_2-4-提供者与消费者" tabindex="-1"><a class="header-anchor" href="#_2-4-提供者与消费者" aria-hidden="true">#</a> 2.4.提供者与消费者</h2>
<p>在服务调用关系中，会有两个不同的角色：</p>
<p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p>
<p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713214404481.png" alt="image-20210713214404481"></p>
<p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p>
<p>如果服务 A 调用了服务 B，而服务 B 又调用了服务 C，服务 B 的角色是什么？</p>
<ul>
<li>对于 A 调用 B 的业务而言：A 是服务消费者，B 是服务提供者</li>
<li>对于 B 调用 C 的业务而言：B 是服务消费者，C 是服务提供者</li>
</ul>
<p>因此，服务 B 既可以是服务提供者，也可以是服务消费者。</p>
<h1 id="_3-eureka-注册中心" tabindex="-1"><a class="header-anchor" href="#_3-eureka-注册中心" aria-hidden="true">#</a> 3.Eureka 注册中心</h1>
<p>假如我们的服务提供者 user-service 部署了多个实例，如图：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713214925388.png" alt="image-20210713214925388"></p>
<p>大家思考几个问题：</p>
<ul>
<li>order-service 在发起远程调用的时候，该如何得知 user-service 实例的 ip 地址和端口？</li>
<li>有多个 user-service 实例地址，order-service 调用时该如何选择？</li>
<li>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</li>
</ul>
<h2 id="_3-1-eureka-的结构和作用" tabindex="-1"><a class="header-anchor" href="#_3-1-eureka-的结构和作用" aria-hidden="true">#</a> 3.1.Eureka 的结构和作用</h2>
<p>这些问题都需要利用 SpringCloud 中的注册中心来解决，其中最广为人知的注册中心就是 Eureka，其结构如下：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713220104956.png" alt="image-20210713220104956"></p>
<p>回答之前的各个问题。</p>
<p>问题 1：order-service 如何得知 user-service 实例地址？</p>
<p>获取地址信息的流程如下：</p>
<ul>
<li>user-service 服务实例启动后，将自己的信息注册到 eureka-server（Eureka 服务端）。这个叫服务注册</li>
<li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li>
<li>order-service 根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li>
</ul>
<p>问题 2：order-service 如何从多个 user-service 实例中选择具体的实例？</p>
<ul>
<li>order-service 从实例列表中利用负载均衡算法选中一个实例地址</li>
<li>向该实例地址发起远程调用</li>
</ul>
<p>问题 3：order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</p>
<ul>
<li>user-service 会每隔一段时间（默认 30 秒）向 eureka-server 发起请求，报告自己状态，称为心跳</li>
<li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li>
<li>order-service 拉取服务时，就能将故障实例排除了</li>
</ul>
<blockquote>
<p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此 eureka 将服务注册、服务发现等功能统一封装到了 eureka-client 端</p>
</blockquote>
<p>因此，接下来我们动手实践的步骤包括：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713220509769.png" alt="image-20210713220509769"></p>
<h2 id="_3-2-搭建-eureka-server" tabindex="-1"><a class="header-anchor" href="#_3-2-搭建-eureka-server" aria-hidden="true">#</a> 3.2.搭建 eureka-server</h2>
<p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p>
<h3 id="_3-2-1-创建-eureka-server-服务" tabindex="-1"><a class="header-anchor" href="#_3-2-1-创建-eureka-server-服务" aria-hidden="true">#</a> 3.2.1.创建 eureka-server 服务</h3>
<p>在 cloud-demo 父工程下，创建一个子模块：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713220605881.png" alt="image-20210713220605881"></p>
<p>填写模块信息：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713220857396.png" alt="image-20210713220857396"></p>
<p>然后填写服务信息：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713221339022.png" alt="image-20210713221339022"></p>
<h3 id="_3-2-2-引入-eureka-依赖" tabindex="-1"><a class="header-anchor" href="#_3-2-2-引入-eureka-依赖" aria-hidden="true">#</a> 3.2.2.引入 eureka 依赖</h3>
<p>引入 SpringCloud 为 eureka 提供的 starter 依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre v-pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-3-编写启动类" tabindex="-1"><a class="header-anchor" href="#_3-2-3-编写启动类" aria-hidden="true">#</a> 3.2.3.编写启动类</h3>
<p>给 eureka-server 服务编写一个启动类，一定要添加一个@EnableEurekaServer 注解，开启 eureka 的注册中心功能：</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre v-pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>eureka</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>eureka<span class="token punctuation">.</span>server<span class="token punctuation">.</span></span><span class="token class-name">EnableEurekaServer</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableEurekaServer</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EurekaApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-4-编写配置文件" tabindex="-1"><a class="header-anchor" href="#_3-2-4-编写配置文件" aria-hidden="true">#</a> 3.2.4.编写配置文件</h3>
<p>编写一个 application.yml 文件，内容如下：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10086</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-5-启动服务" tabindex="-1"><a class="header-anchor" href="#_3-2-5-启动服务" aria-hidden="true">#</a> 3.2.5.启动服务</h3>
<p>启动微服务，然后在浏览器访问：http://127.0.0.1:10086</p>
<p>看到下面结果应该是成功了：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713222157190.png" alt="image-20210713222157190"></p>
<h2 id="_3-3-服务注册" tabindex="-1"><a class="header-anchor" href="#_3-3-服务注册" aria-hidden="true">#</a> 3.3.服务注册</h2>
<p>下面，我们将 user-service 注册到 eureka-server 中去。</p>
<h3 id="_1-引入依赖" tabindex="-1"><a class="header-anchor" href="#_1-引入依赖" aria-hidden="true">#</a> 1）引入依赖</h3>
<p>在 user-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre v-pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-配置文件" tabindex="-1"><a class="header-anchor" href="#_2-配置文件" aria-hidden="true">#</a> 2）配置文件</h3>
<p>在 user-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-启动多个-user-service-实例" tabindex="-1"><a class="header-anchor" href="#_3-启动多个-user-service-实例" aria-hidden="true">#</a> 3）启动多个 user-service 实例</h3>
<p>为了演示一个服务有多个实例的场景，我们添加一个 SpringBoot 的启动配置，再启动一个 user-service。</p>
<p>首先，复制原来的 user-service 启动配置：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713222656562.png" alt="image-20210713222656562"></p>
<p>然后，在弹出的窗口中，填写信息：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713222757702.png" alt="image-20210713222757702"></p>
<p>现在，SpringBoot 窗口会出现两个 user-service 启动配置：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713222841951.png" alt="image-20210713222841951"></p>
<p>不过，第一个是 8081 端口，第二个是 8082 端口。</p>
<p>启动两个 user-service 实例：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713223041491.png" alt="image-20210713223041491"></p>
<p>查看 eureka-server 管理页面：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713223150650.png" alt="image-20210713223150650"></p>
<h2 id="_3-4-服务发现" tabindex="-1"><a class="header-anchor" href="#_3-4-服务发现" aria-hidden="true">#</a> 3.4.服务发现</h2>
<p>下面，我们将 order-service 的逻辑修改：向 eureka-server 拉取 user-service 的信息，实现服务发现。</p>
<h3 id="_1-引入依赖-1" tabindex="-1"><a class="header-anchor" href="#_1-引入依赖-1" aria-hidden="true">#</a> 1）引入依赖</h3>
<p>之前说过，服务发现、服务注册统一都封装在 eureka-client 依赖，因此这一步与服务注册时一致。</p>
<p>在 order-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre v-pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-配置文件-1" tabindex="-1"><a class="header-anchor" href="#_2-配置文件-1" aria-hidden="true">#</a> 2）配置文件</h3>
<p>服务发现也需要知道 eureka 地址，因此第二步与服务注册一致，都是配置 eureka 信息：</p>
<p>在 order-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> orderservice
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-服务拉取和负载均衡" tabindex="-1"><a class="header-anchor" href="#_3-服务拉取和负载均衡" aria-hidden="true">#</a> 3）服务拉取和负载均衡</h3>
<p>最后，我们要去 eureka-server 中拉取 user-service 服务的实例列表，并且实现负载均衡。</p>
<p>不过这些动作不用我们去做，只需要添加一些注解即可。</p>
<p>在 order-service 的 OrderApplication 中，给 RestTemplate 这个 Bean 添加一个@LoadBalanced 注解：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713224049419.png" alt="image-20210713224049419"></p>
<p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法。修改访问的 url 路径，用服务名代替 ip、端口：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713224245731.png" alt="image-20210713224245731"></p>
<p>spring 会自动帮助我们从 eureka-server 端，根据 userservice 这个服务名称，获取实例列表，而后完成负载均衡。</p>
<h1 id="_4-ribbon-负载均衡" tabindex="-1"><a class="header-anchor" href="#_4-ribbon-负载均衡" aria-hidden="true">#</a> 4.Ribbon 负载均衡</h1>
<p>上一节中，我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？</p>
<h2 id="_4-1-负载均衡原理" tabindex="-1"><a class="header-anchor" href="#_4-1-负载均衡原理" aria-hidden="true">#</a> 4.1.负载均衡原理</h2>
<p>SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713224517686.png" alt="image-20210713224517686"></p>
<p>那么我们发出的请求明明是 http://userservice/user/1，怎么变成了 http://localhost:8081 的呢？</p>
<h2 id="_4-2-源码跟踪" tabindex="-1"><a class="header-anchor" href="#_4-2-源码跟踪" aria-hidden="true">#</a> 4.2.源码跟踪</h2>
<p>为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p>
<p>显然有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是<code v-pre>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p>
<p>我们进行源码跟踪：</p>
<h3 id="_1-loadbalancerintercepor" tabindex="-1"><a class="header-anchor" href="#_1-loadbalancerintercepor" aria-hidden="true">#</a> 1）LoadBalancerIntercepor</h3>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/1525620483637.png" alt="1525620483637"></p>
<p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p>
<ul>
<li><code v-pre>request.getURI()</code>：获取请求 uri，本例中就是 http://user-service/user/8</li>
<li><code v-pre>originalUri.getHost()</code>：获取 uri 路径的主机名，其实就是服务 id，<code v-pre>user-service</code></li>
<li><code v-pre>this.loadBalancer.execute()</code>：处理服务 id，和用户请求。</li>
</ul>
<p>这里的<code v-pre>this.loadBalancer</code>是<code v-pre>LoadBalancerClient</code>类型，我们继续跟入。</p>
<h3 id="_2-loadbalancerclient" tabindex="-1"><a class="header-anchor" href="#_2-loadbalancerclient" aria-hidden="true">#</a> 2）LoadBalancerClient</h3>
<p>继续跟入 execute 方法：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/1525620787090.png" alt="1525620787090"></p>
<p>代码是这样的：</p>
<ul>
<li>getLoadBalancer(serviceId)：根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来。</li>
<li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了 8082 端口的服务</li>
</ul>
<p>放行后，再次访问并跟踪，发现获取的是 8081：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/1525620835911.png" alt="1525620835911"></p>
<p>果然实现了负载均衡。</p>
<h3 id="_3-负载均衡策略-irule" tabindex="-1"><a class="header-anchor" href="#_3-负载均衡策略-irule" aria-hidden="true">#</a> 3）负载均衡策略 IRule</h3>
<p>在刚才的代码中，可以看到获取服务使通过一个<code v-pre>getServer</code>方法来做负载均衡:</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/1525620835911.png" alt="1525620835911"></p>
<p>我们继续跟入：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/1544361421671.png" alt="1544361421671"></p>
<p>继续跟踪源码 chooseServer 方法，发现这么一段代码：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/1525622652849.png" alt="1525622652849"></p>
<p>我们看看这个 rule 是谁：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/1525622699666.png" alt="1525622699666"></p>
<p>这里的 rule 默认值是一个<code v-pre>RoundRobinRule</code>，看类的介绍：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/1525622754316.png" alt="1525622754316"></p>
<p>这不就是轮询的意思嘛。</p>
<p>到这里，整个负载均衡的流程我们就清楚了。</p>
<h3 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4）总结</h3>
<p>SpringCloudRibbon 的底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。用一幅图来总结一下：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713224724673.png" alt="image-20210713224724673"></p>
<p>基本流程如下：</p>
<ul>
<li>拦截我们的 RestTemplate 请求 http://userservice/user/1</li>
<li>RibbonLoadBalancerClient 会从请求 url 中获取服务名称，也就是 user-service</li>
<li>DynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表</li>
<li>eureka 返回列表，localhost:8081、localhost:8082</li>
<li>IRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li>
<li>RibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 http://localhost:8081/user/1，发起真实请求</li>
</ul>
<h2 id="_4-3-负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-负载均衡策略" aria-hidden="true">#</a> 4.3.负载均衡策略</h2>
<h3 id="_4-3-1-负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-1-负载均衡策略" aria-hidden="true">#</a> 4.3.1.负载均衡策略</h3>
<p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713225653000.png" alt="image-20210713225653000"></p>
<p>不同规则的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>内置负载均衡规则类</strong></th>
<th><strong>规则描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>RoundRobinRule</td>
<td>简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则。</td>
</tr>
<tr>
<td>AvailabilityFilteringRule</td>
<td>对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<code v-pre>&lt;clientName&gt;</code>.<code v-pre>&lt;clientConfigNameSpace&gt;</code>.ActiveConnectionsLimit 属性进行配置。</td>
</tr>
<tr>
<td>WeightedResponseTimeRule</td>
<td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td>
</tr>
<tr>
<td><strong>ZoneAvoidanceRule</strong></td>
<td>以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询。</td>
</tr>
<tr>
<td>BestAvailableRule</td>
<td>忽略那些短路的服务器，并选择并发数较低的服务器。</td>
</tr>
<tr>
<td>RandomRule</td>
<td>随机选择一个可用的服务器。</td>
</tr>
<tr>
<td>RetryRule</td>
<td>重试机制的选择逻辑</td>
</tr>
</tbody>
</table>
<p>默认的实现就是 ZoneAvoidanceRule，是一种轮询方案</p>
<h3 id="_4-3-2-自定义负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-2-自定义负载均衡策略" aria-hidden="true">#</a> 4.3.2.自定义负载均衡策略</h3>
<p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p>
<ol>
<li>代码方式：在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><pre v-pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">randomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</li>
</ol>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment"># 负载均衡规则</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p>
</blockquote>
<h2 id="_4-4-饥饿加载" tabindex="-1"><a class="header-anchor" href="#_4-4-饥饿加载" aria-hidden="true">#</a> 4.4.饥饿加载</h2>
<p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间(请求 eurekaClient 列表)会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token key atrule">eager-load</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">clients</span><span class="token punctuation">:</span> userservice
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_5-nacos-注册中心" tabindex="-1"><a class="header-anchor" href="#_5-nacos-注册中心" aria-hidden="true">#</a> 5.Nacos 注册中心</h1>
<p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba 也推出了一个名为 Nacos 的注册中心。</p>
<h2 id="_5-1-认识和安装-nacos" tabindex="-1"><a class="header-anchor" href="#_5-1-认识和安装-nacos" aria-hidden="true">#</a> 5.1.认识和安装 Nacos</h2>
<p><a href="https://nacos.io/" target="_blank" rel="noopener noreferrer">Nacos<ExternalLinkIcon/></a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud<ExternalLinkIcon/></a>中的一个组件。相比<a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener noreferrer">Eureka<ExternalLinkIcon/></a>功能更加丰富，在国内受欢迎程度较高。</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713230444308.png" alt="image-20210713230444308"></p>
<p>安装方式可以参考课前资料《Nacos 安装指南.md》</p>
<h2 id="_5-2-服务注册到-nacos" tabindex="-1"><a class="header-anchor" href="#_5-2-服务注册到-nacos" aria-hidden="true">#</a> 5.2.服务注册到 nacos</h2>
<p>Nacos 是 SpringCloudAlibaba 的组件，而 SpringCloudAlibaba 也遵循 SpringCloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。</p>
<p>主要差异在于：</p>
<ul>
<li>依赖不同</li>
<li>服务地址不同</li>
</ul>
<h3 id="_1-引入依赖-2" tabindex="-1"><a class="header-anchor" href="#_1-引入依赖-2" aria-hidden="true">#</a> 1）引入依赖</h3>
<p>在 cloud-demo 父工程的 pom 文件中的<code v-pre>&lt;dependencyManagement&gt;</code>中引入 SpringCloudAlibaba 的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre v-pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在 user-service 和 order-service 中的 pom 文件中引入 nacos-discovery 依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><pre v-pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>注意</strong>：不要忘了注释掉 eureka 的依赖。</p>
</blockquote>
<h3 id="_2-配置-nacos-地址" tabindex="-1"><a class="header-anchor" href="#_2-配置-nacos-地址" aria-hidden="true">#</a> 2）配置 nacos 地址</h3>
<p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>注意</strong>：不要忘了注释掉 eureka 的地址</p>
</blockquote>
<h3 id="_3-重启" tabindex="-1"><a class="header-anchor" href="#_3-重启" aria-hidden="true">#</a> 3）重启</h3>
<p>重启微服务后，登录 nacos 管理页面，可以看到微服务信息：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713231439607.png" alt="image-20210713231439607"></p>
<h2 id="_5-3-服务分级存储模型" tabindex="-1"><a class="header-anchor" href="#_5-3-服务分级存储模型" aria-hidden="true">#</a> 5.3.服务分级存储模型</h2>
<p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p>
<ul>
<li>127.0.0.1:8081</li>
<li>127.0.0.1:8082</li>
<li>127.0.0.1:8083</li>
</ul>
<p>假如这些实例分布于全国各地的不同机房，例如：</p>
<ul>
<li>127.0.0.1:8081，在上海机房</li>
<li>127.0.0.1:8082，在上海机房</li>
<li>127.0.0.1:8083，在杭州机房</li>
</ul>
<p>Nacos 就将同一机房内的实例 划分为一个<strong>集群</strong>。</p>
<p>也就是说，user-service 是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713232522531.png" alt="image-20210713232522531"></p>
<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713232658928.png" alt="image-20210713232658928"></p>
<p>杭州机房内的 order-service 应该优先访问同机房的 user-service。</p>
<h3 id="_5-3-1-给-user-service-配置集群" tabindex="-1"><a class="header-anchor" href="#_5-3-1-给-user-service-配置集群" aria-hidden="true">#</a> 5.3.1.给 user-service 配置集群</h3>
<p>修改 user-service 的 application.yml 文件，添加集群配置：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ <span class="token comment"># 集群名称</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启两个 user-service 实例后，我们可以在 nacos 控制台看到下面结果：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713232916215.png" alt="image-20210713232916215"></p>
<p>我们再次复制一个 user-service 启动配置，添加属性：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><pre v-pre class="language-bash"><code><span class="token parameter variable">-Dserver.port</span><span class="token operator">=</span><span class="token number">8083</span> -Dspring.cloud.nacos.discovery.cluster-name<span class="token operator">=</span>SH
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>配置如图所示：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713233528982.png" alt="image-20210713233528982"></p>
<p>启动 UserApplication3 后再次查看 nacos 控制台：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713233727923.png" alt="image-20210713233727923"></p>
<h3 id="_5-3-2-同集群优先的负载均衡" tabindex="-1"><a class="header-anchor" href="#_5-3-2-同集群优先的负载均衡" aria-hidden="true">#</a> 5.3.2.同集群优先的负载均衡</h3>
<p>默认的<code v-pre>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p>
<p>因此 Nacos 中提供了一个<code v-pre>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p>
<p>1）给 order-service 配置集群信息</p>
<p>修改 order-service 的 application.yml 文件，添加集群配置：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><pre v-pre class="language-bash"><code>spring:
  cloud:
    nacos:
      server-addr: localhost:8848
      discovery:
        cluster-name: HZ <span class="token comment"># 集群名称</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2）修改负载均衡规则</p>
<p>修改 order-service 的 application.yml 文件，修改负载均衡规则：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">userservice</span><span class="token punctuation">:</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.alibaba.cloud.nacos.ribbon.NacosRule <span class="token comment"># 负载均衡规则</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-4-权重配置" tabindex="-1"><a class="header-anchor" href="#_5-4-权重配置" aria-hidden="true">#</a> 5.4.权重配置</h2>
<p>实际部署中会出现这样的场景：</p>
<p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p>
<p>但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p>
<p>因此，Nacos 提供了权重配置来控制访问频率，权重越大则访问频率越高。</p>
<p>在 nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713235133225.png" alt="image-20210713235133225"></p>
<p>在弹出的编辑窗口，修改权重：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210713235235219.png" alt="image-20210713235235219"></p>
<blockquote>
<p><strong>注意</strong>：如果权重修改为 0，则该实例永远不会被访问</p>
</blockquote>
<h2 id="_5-5-环境隔离" tabindex="-1"><a class="header-anchor" href="#_5-5-环境隔离" aria-hidden="true">#</a> 5.5.环境隔离</h2>
<p>Nacos 提供了 namespace 来实现环境隔离功能。</p>
<ul>
<li>nacos 中可以有多个 namespace</li>
<li>namespace 下可以有 group、service 等</li>
<li>不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见</li>
</ul>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714000101516.png" alt="image-20210714000101516"></p>
<h3 id="_5-5-1-创建-namespace" tabindex="-1"><a class="header-anchor" href="#_5-5-1-创建-namespace" aria-hidden="true">#</a> 5.5.1.创建 namespace</h3>
<p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714000414781.png" alt="image-20210714000414781"></p>
<p>我们可以点击页面新增按钮，添加一个 namespace：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714000440143.png" alt="image-20210714000440143"></p>
<p>然后，填写表单：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714000505928.png" alt="image-20210714000505928"></p>
<p>就能在页面看到一个新的 namespace：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714000522913.png" alt="image-20210714000522913"></p>
<h3 id="_5-5-2-给微服务配置-namespace" tabindex="-1"><a class="header-anchor" href="#_5-5-2-给微服务配置-namespace" aria-hidden="true">#</a> 5.5.2.给微服务配置 namespace</h3>
<p>给微服务配置 namespace 只能通过修改配置来实现。</p>
<p>例如，修改 order-service 的 application.yml 文件：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ
        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 492a7d5d<span class="token punctuation">-</span>237b<span class="token punctuation">-</span>46a1<span class="token punctuation">-</span>a99a<span class="token punctuation">-</span>fa8e98e4b0f9 <span class="token comment"># 命名空间，填ID</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启 order-service 后，访问控制台，可以看到下面的结果：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714000830703.png" alt="image-20210714000830703"></p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714000837140.png" alt="image-20210714000837140"></p>
<p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714000941256.png" alt="image-20210714000941256"></p>
<h2 id="_5-6-nacos-与-eureka-的区别" tabindex="-1"><a class="header-anchor" href="#_5-6-nacos-与-eureka-的区别" aria-hidden="true">#</a> 5.6.Nacos 与 Eureka 的区别</h2>
<p>Nacos 的服务实例分为两种 l 类型：</p>
<ul>
<li>
<p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p>
</li>
<li>
<p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p>
</li>
</ul>
<p>配置一个服务实例为永久实例：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><pre v-pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">ephemeral</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置为非临时实例</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Nacos 和 Eureka 整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p>
<p><img src="@source/notes/microservices/01/day01-SpringCloud01/assets/image-20210714001728017.png" alt="image-20210714001728017"></p>
<ul>
<li>
<p>Nacos 与 eureka 的共同点</p>
<ul>
<li>都支持服务注册和服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>
<p>Nacos 与 Eureka 的区别</p>
<ul>
<li>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka 采用 AP 方式</li>
</ul>
</li>
</ul>
</div></template>


